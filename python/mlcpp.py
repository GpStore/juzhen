# This file was automatically generated by SWIG (http://www.swig.org).
# Version 2.0.1
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.
# This file is compatible with both classic and new-style classes.

from sys import version_info
if version_info >= (2,6,0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_mlcpp', [dirname(__file__)])
        except ImportError:
            import _mlcpp
            return _mlcpp
        if fp is not None:
            try:
                _mod = imp.load_module('_mlcpp', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _mlcpp = swig_import_helper()
    del swig_import_helper
else:
    import _mlcpp
del version_info
try:
    _swig_property = property
except NameError:
    pass # Python < 2.2 doesn't have 'property'.
def _swig_setattr_nondynamic(self,class_type,name,value,static=1):
    if (name == "thisown"): return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name,None)
    if method: return method(self,value)
    if (not static) or hasattr(self,name):
        self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)

def _swig_setattr(self,class_type,name,value):
    return _swig_setattr_nondynamic(self,class_type,name,value,0)

def _swig_getattr(self,class_type,name):
    if (name == "thisown"): return self.this.own()
    method = class_type.__swig_getmethods__.get(name,None)
    if method: return method(self)
    raise AttributeError(name)

def _swig_repr(self):
    try: strthis = "proxy of " + self.this.__repr__()
    except: strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object : pass
    _newclass = 0


class Complex(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Complex, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Complex, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        this = _mlcpp.new_Complex(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _mlcpp.delete_Complex
    __del__ = lambda self : None;
    def __eq__(self, *args): return _mlcpp.Complex___eq__(self, *args)
    def __ne__(self, *args): return _mlcpp.Complex___ne__(self, *args)
    def __str__(self): return _mlcpp.Complex___str__(self)
    def __add__(self, *args): return _mlcpp.Complex___add__(self, *args)
    def __sub__(self, *args): return _mlcpp.Complex___sub__(self, *args)
    def __mul__(self, *args): return _mlcpp.Complex___mul__(self, *args)
    def __div__(self, *args): return _mlcpp.Complex___div__(self, *args)
    def conj(self): return _mlcpp.Complex_conj(self)
    def abs(self): return _mlcpp.Complex_abs(self)
    __swig_setmethods__["real"] = _mlcpp.Complex_real_set
    __swig_getmethods__["real"] = _mlcpp.Complex_real_get
    if _newclass:real = _swig_property(_mlcpp.Complex_real_get, _mlcpp.Complex_real_set)
    __swig_setmethods__["imag"] = _mlcpp.Complex_imag_set
    __swig_getmethods__["imag"] = _mlcpp.Complex_imag_get
    if _newclass:imag = _swig_property(_mlcpp.Complex_imag_get, _mlcpp.Complex_imag_set)
Complex_swigregister = _mlcpp.Complex_swigregister
Complex_swigregister(Complex)

class Matrix(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Matrix, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Matrix, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        this = _mlcpp.new_Matrix(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _mlcpp.delete_Matrix
    __del__ = lambda self : None;
    def __eq__(self, *args): return _mlcpp.Matrix___eq__(self, *args)
    def __ne__(self, *args): return _mlcpp.Matrix___ne__(self, *args)
    def num_row(self): return _mlcpp.Matrix_num_row(self)
    def num_col(self): return _mlcpp.Matrix_num_col(self)
    def resize(self, *args): return _mlcpp.Matrix_resize(self, *args)
    def clear(self): return _mlcpp.Matrix_clear(self)
    def conj(self): return _mlcpp.Matrix_conj(self)
    def trans(self): return _mlcpp.Matrix_trans(self)
    def adj(self): return _mlcpp.Matrix_adj(self)
    def get_col(self, *args): return _mlcpp.Matrix_get_col(self, *args)
    def get_row(self, *args): return _mlcpp.Matrix_get_row(self, *args)
    def block(self, *args): return _mlcpp.Matrix_block(self, *args)
    def replace(self, *args): return _mlcpp.Matrix_replace(self, *args)
    def swap_col(self, *args): return _mlcpp.Matrix_swap_col(self, *args)
    def swap_row(self, *args): return _mlcpp.Matrix_swap_row(self, *args)
    def __str__(self): return _mlcpp.Matrix___str__(self)
    def __getitem__(self, *args): return _mlcpp.Matrix___getitem__(self, *args)
    def copy(self): return _mlcpp.Matrix_copy(self)
    def set(self, *args): return _mlcpp.Matrix_set(self, *args)
    def get(self, *args): return _mlcpp.Matrix_get(self, *args)
    def __add__(self, *args): return _mlcpp.Matrix___add__(self, *args)
    def __sub__(self, *args): return _mlcpp.Matrix___sub__(self, *args)
    def __mul__(self, *args): return _mlcpp.Matrix___mul__(self, *args)
    def __div__(self, *args): return _mlcpp.Matrix___div__(self, *args)
    def real(self): return _mlcpp.Matrix_real(self)
    def imag(self): return _mlcpp.Matrix_imag(self)
    def inverse(self): return _mlcpp.Matrix_inverse(self)
    def linear_solver(self, *args): return _mlcpp.Matrix_linear_solver(self, *args)
    def eigen(self, *args): return _mlcpp.Matrix_eigen(self, *args)
    def left_eigen(self, *args): return _mlcpp.Matrix_left_eigen(self, *args)
    def right_eigen(self, *args): return _mlcpp.Matrix_right_eigen(self, *args)
Matrix_swigregister = _mlcpp.Matrix_swigregister
Matrix_swigregister(Matrix)

class CMatrix(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CMatrix, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CMatrix, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        this = _mlcpp.new_CMatrix(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _mlcpp.delete_CMatrix
    __del__ = lambda self : None;
    def __eq__(self, *args): return _mlcpp.CMatrix___eq__(self, *args)
    def __ne__(self, *args): return _mlcpp.CMatrix___ne__(self, *args)
    def num_row(self): return _mlcpp.CMatrix_num_row(self)
    def num_col(self): return _mlcpp.CMatrix_num_col(self)
    def resize(self, *args): return _mlcpp.CMatrix_resize(self, *args)
    def clear(self): return _mlcpp.CMatrix_clear(self)
    def conj(self): return _mlcpp.CMatrix_conj(self)
    def trans(self): return _mlcpp.CMatrix_trans(self)
    def adj(self): return _mlcpp.CMatrix_adj(self)
    def get_col(self, *args): return _mlcpp.CMatrix_get_col(self, *args)
    def get_row(self, *args): return _mlcpp.CMatrix_get_row(self, *args)
    def block(self, *args): return _mlcpp.CMatrix_block(self, *args)
    def replace(self, *args): return _mlcpp.CMatrix_replace(self, *args)
    def swap_col(self, *args): return _mlcpp.CMatrix_swap_col(self, *args)
    def swap_row(self, *args): return _mlcpp.CMatrix_swap_row(self, *args)
    def __str__(self): return _mlcpp.CMatrix___str__(self)
    def __getitem__(self, *args): return _mlcpp.CMatrix___getitem__(self, *args)
    def copy(self): return _mlcpp.CMatrix_copy(self)
    def set(self, *args): return _mlcpp.CMatrix_set(self, *args)
    def get(self, *args): return _mlcpp.CMatrix_get(self, *args)
    def __add__(self, *args): return _mlcpp.CMatrix___add__(self, *args)
    def __sub__(self, *args): return _mlcpp.CMatrix___sub__(self, *args)
    def __mul__(self, *args): return _mlcpp.CMatrix___mul__(self, *args)
    def __div__(self, *args): return _mlcpp.CMatrix___div__(self, *args)
    def real(self): return _mlcpp.CMatrix_real(self)
    def imag(self): return _mlcpp.CMatrix_imag(self)
    def inverse(self): return _mlcpp.CMatrix_inverse(self)
    def linear_solver(self, *args): return _mlcpp.CMatrix_linear_solver(self, *args)
    def eigen(self, *args): return _mlcpp.CMatrix_eigen(self, *args)
    def left_eigen(self, *args): return _mlcpp.CMatrix_left_eigen(self, *args)
    def right_eigen(self, *args): return _mlcpp.CMatrix_right_eigen(self, *args)
CMatrix_swigregister = _mlcpp.CMatrix_swigregister
CMatrix_swigregister(CMatrix)


def Identity(*args):
  return _mlcpp.Identity(*args)
Identity = _mlcpp.Identity

def CIdentity(*args):
  return _mlcpp.CIdentity(*args)
CIdentity = _mlcpp.CIdentity
class Vector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Vector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Vector, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        this = _mlcpp.new_Vector(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _mlcpp.delete_Vector
    __del__ = lambda self : None;
    def __eq__(self, *args): return _mlcpp.Vector___eq__(self, *args)
    def __ne__(self, *args): return _mlcpp.Vector___ne__(self, *args)
    def size(self): return _mlcpp.Vector_size(self)
    def resize(self, *args): return _mlcpp.Vector_resize(self, *args)
    def clear(self): return _mlcpp.Vector_clear(self)
    def conj(self): return _mlcpp.Vector_conj(self)
    def trans(self): return _mlcpp.Vector_trans(self)
    def adj(self): return _mlcpp.Vector_adj(self)
    def Sort(self): return _mlcpp.Vector_Sort(self)
    def block(self, *args): return _mlcpp.Vector_block(self, *args)
    def replace(self, *args): return _mlcpp.Vector_replace(self, *args)
    def swap(self, *args): return _mlcpp.Vector_swap(self, *args)
    def __str__(self): return _mlcpp.Vector___str__(self)
    def __getitem__(self, *args): return _mlcpp.Vector___getitem__(self, *args)
    def copy(self): return _mlcpp.Vector_copy(self)
    def set(self, *args): return _mlcpp.Vector_set(self, *args)
    def get(self, *args): return _mlcpp.Vector_get(self, *args)
    def __add__(self, *args): return _mlcpp.Vector___add__(self, *args)
    def __sub__(self, *args): return _mlcpp.Vector___sub__(self, *args)
    def __mul__(self, *args): return _mlcpp.Vector___mul__(self, *args)
    def __div__(self, *args): return _mlcpp.Vector___div__(self, *args)
    def real(self): return _mlcpp.Vector_real(self)
    def imag(self): return _mlcpp.Vector_imag(self)
Vector_swigregister = _mlcpp.Vector_swigregister
Vector_swigregister(Vector)

class CVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CVector, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        this = _mlcpp.new_CVector(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _mlcpp.delete_CVector
    __del__ = lambda self : None;
    def __eq__(self, *args): return _mlcpp.CVector___eq__(self, *args)
    def __ne__(self, *args): return _mlcpp.CVector___ne__(self, *args)
    def size(self): return _mlcpp.CVector_size(self)
    def resize(self, *args): return _mlcpp.CVector_resize(self, *args)
    def clear(self): return _mlcpp.CVector_clear(self)
    def conj(self): return _mlcpp.CVector_conj(self)
    def trans(self): return _mlcpp.CVector_trans(self)
    def adj(self): return _mlcpp.CVector_adj(self)
    def block(self, *args): return _mlcpp.CVector_block(self, *args)
    def replace(self, *args): return _mlcpp.CVector_replace(self, *args)
    def swap(self, *args): return _mlcpp.CVector_swap(self, *args)
    def __str__(self): return _mlcpp.CVector___str__(self)
    def __getitem__(self, *args): return _mlcpp.CVector___getitem__(self, *args)
    def copy(self): return _mlcpp.CVector_copy(self)
    def set(self, *args): return _mlcpp.CVector_set(self, *args)
    def get(self, *args): return _mlcpp.CVector_get(self, *args)
    def __add__(self, *args): return _mlcpp.CVector___add__(self, *args)
    def __sub__(self, *args): return _mlcpp.CVector___sub__(self, *args)
    def __mul__(self, *args): return _mlcpp.CVector___mul__(self, *args)
    def __div__(self, *args): return _mlcpp.CVector___div__(self, *args)
    def real(self): return _mlcpp.CVector_real(self)
    def imag(self): return _mlcpp.CVector_imag(self)
CVector_swigregister = _mlcpp.CVector_swigregister
CVector_swigregister(CVector)

def inverse(a):
    return a.inverse()

def linear_solver(a, b):
    return a.linear_solver(b)

def eigen(a):
    e = CMatrix()
    if type(a).__name__ == "Matrix":
      vl = Matrix()
      vr = Matrix()
    else:
      vl = CMatrix()
      vr = CMatrix()
    a.eigen(e, vl, vr)
    return (e, vl, vr)

def right_eigen(a):
    e = CMatrix()
    if type(a).__name__ == "Matrix":
      vr = Matrix()
    else:
      vr = CMatrix()
    a.right_eigen(e, vr)
    return (e, vr)

def left_eigen(a):
    e = CMatrix()
    if type(a).__name__ == "Matrix":
      vr = Matrix()
    else:
      vr = CMatrix()
    a.left_eigen(e, vr)
    return (e, vr)



def sort(*args):
  return _mlcpp.sort(*args)
sort = _mlcpp.sort

def cov(*args):
  return _mlcpp.cov(*args)
cov = _mlcpp.cov

def var(*args):
  return _mlcpp.var(*args)
var = _mlcpp.var

def std_dev(*args):
  return _mlcpp.std_dev(*args)
std_dev = _mlcpp.std_dev

def corr_coeff(*args):
  return _mlcpp.corr_coeff(*args)
corr_coeff = _mlcpp.corr_coeff


def transpose(*args):
  return _mlcpp.transpose(*args)
transpose = _mlcpp.transpose

def adjoint(*args):
  return _mlcpp.adjoint(*args)
adjoint = _mlcpp.adjoint

def conjugate(*args):
  return _mlcpp.conjugate(*args)
conjugate = _mlcpp.conjugate

def join(*args):
  return _mlcpp.join(*args)
join = _mlcpp.join

def outer_product(*args):
  return _mlcpp.outer_product(*args)
outer_product = _mlcpp.outer_product

def cross_product(*args):
  return _mlcpp.cross_product(*args)
cross_product = _mlcpp.cross_product

def sum(*args):
  return _mlcpp.sum(*args)
sum = _mlcpp.sum

def mean(*args):
  return _mlcpp.mean(*args)
mean = _mlcpp.mean

def norm(*args):
  return _mlcpp.norm(*args)
norm = _mlcpp.norm

def max(*args):
  return _mlcpp.max(*args)
max = _mlcpp.max

def min(*args):
  return _mlcpp.min(*args)
min = _mlcpp.min

def randomize(*args):
  return _mlcpp.randomize(*args)
randomize = _mlcpp.randomize

def least_squares_method(*args):
  return _mlcpp.least_squares_method(*args)
least_squares_method = _mlcpp.least_squares_method

def trace(*args):
  return _mlcpp.trace(*args)
trace = _mlcpp.trace

def schur_product(*args):
  return _mlcpp.schur_product(*args)
schur_product = _mlcpp.schur_product

def kronecker_product(*args):
  return _mlcpp.kronecker_product(*args)
kronecker_product = _mlcpp.kronecker_product

def inner_product(*args):
  return _mlcpp.inner_product(*args)
inner_product = _mlcpp.inner_product

def cos(*args):
  return _mlcpp.cos(*args)
cos = _mlcpp.cos

def sin(*args):
  return _mlcpp.sin(*args)
sin = _mlcpp.sin

def tan(*args):
  return _mlcpp.tan(*args)
tan = _mlcpp.tan

def acos(*args):
  return _mlcpp.acos(*args)
acos = _mlcpp.acos

def asin(*args):
  return _mlcpp.asin(*args)
asin = _mlcpp.asin

def atan(*args):
  return _mlcpp.atan(*args)
atan = _mlcpp.atan

def cosh(*args):
  return _mlcpp.cosh(*args)
cosh = _mlcpp.cosh

def sinh(*args):
  return _mlcpp.sinh(*args)
sinh = _mlcpp.sinh

def tanh(*args):
  return _mlcpp.tanh(*args)
tanh = _mlcpp.tanh

def exp(*args):
  return _mlcpp.exp(*args)
exp = _mlcpp.exp

def log(*args):
  return _mlcpp.log(*args)
log = _mlcpp.log

def log10(*args):
  return _mlcpp.log10(*args)
log10 = _mlcpp.log10

def sqrt(*args):
  return _mlcpp.sqrt(*args)
sqrt = _mlcpp.sqrt

def ceil(*args):
  return _mlcpp.ceil(*args)
ceil = _mlcpp.ceil

def fabs(*args):
  return _mlcpp.fabs(*args)
fabs = _mlcpp.fabs

def floor(*args):
  return _mlcpp.floor(*args)
floor = _mlcpp.floor

